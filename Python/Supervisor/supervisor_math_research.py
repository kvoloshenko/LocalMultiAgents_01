# ============================
# Импорт стандартных библиотек
# ============================

from io import BytesIO              # Для работы с байтовыми потоками (загрузка изображения графа)
from PIL import Image as PILImage   # Для отображения изображений (графа агента)
import os                           # Для доступа к переменным окружения
from dotenv import load_dotenv      # Для загрузки переменных окружения из .env

# ===================================================
# Импорт компонентов из LangChain / LangGraph / Ollama
# ===================================================

from langchain_ollama import ChatOllama          # Интерфейс взаимодействия с локальными LLM (Ollama)
from langgraph_supervisor import create_supervisor  # Создание супервизора агентов
from langgraph.prebuilt import create_react_agent   # Готовый ReAct-агент
# from langgraph_supervisor import create_supervisor  # Создание супервизора агентов
# from langchain.agents import create_agent           # Новый агент на базе LangChain/LangGraph


# ============================================================
# Загрузка переменных окружения (например, ключей LangSmith)
# ============================================================

load_dotenv()  # Загружаем значения из файла .env

# Считываем переменные окружения, если они нужны для трассировки/логирования
LANGSMITH_API_KEY = os.getenv("LANGSMITH_API_KEY")
LANGCHAIN_TRACING_V2 = os.getenv("LANGCHAIN_TRACING_V2")
LANGCHAIN_PROJECT = os.getenv("LANGCHAIN_PROJECT")

# ====================================================
# Инициализация локальной языковой модели через Ollama
# ====================================================

# Старая модель (пример) была бы такой:
# model = ChatOllama(model="qwen2.5:7b-instruct")

# Используем актуальную модель qwen3:latest
model = ChatOllama(model="qwen3:latest")

# ===========================================================
# Создание инструментов (tools) — функций, доступных агентам
# ===========================================================

def add(a: float, b: float) -> float:
    """Сложение двух чисел. Возвращает сумму a + b."""
    return a + b


def multiply(a: float, b: float) -> float:
    """Умножение двух чисел. Возвращает результат a * b."""
    return a * b


def web_search(query: str) -> str:
    """
    Имитация веб-поиска.
    В реальном проекте здесь был бы вызов реального API поиска (Google/Bing/другое).
    Возвращает заранее подготовленные данные — численность сотрудников FAANG в 2024 году.
    """
    return (
        "Вот численность персонала каждой из компаний FAANG в 2024 году:\n:\n"
        "1. **Facebook (Meta)**: 67,317 сотрудников.\n"
        "2. **Apple**: 164,000 сотрудников.\n"
        "3. **Amazon**: 1,551,000 сотрудников.\n"
        "4. **Netflix**: 14,000 сотрудников.\n"
        "5. **Google (Alphabet)**: 181,269 сотрудников."
    )

# =============================================
# Создаём ReAct-агента для математических задач
# =============================================

math_agent = create_react_agent(
    model=model,              # LLM, управляющая агентом
    tools=[add, multiply],    # Инструменты: сложение и умножение
    name="math_expert",       # Имя агента
    prompt=("Ты эксперт в математике. "
            "Всегда используй только один инструмент за раз."
            "Отвечай всегда по-русски")  # Системный промт
)

# ======================================================
# Создаём ReAct-агента для исследовательских запросов
# ======================================================

research_agent = create_react_agent(
    model=model,
    tools=[web_search],       # Инструмент: поиск в интернете (симуляция)
    name="research_expert",
    prompt=("Ты — исследователь мирового уровня с доступом к веб-поиску. "
            "Не занимайся математикой."
            "Отвечай всегда по-русски") # Системный промт
)


# ==================================================
# Создание супервизора, который управляет агентами
# ==================================================

workflow = create_supervisor(
    [research_agent, math_agent],     # Супервизор может выбирать между этими агентами
    model=model,                             # LLM, принимающая решения супервизора
    prompt=(
      "Ты — Supervisor, управляющий научным экспертом и экспертом по математике."
      "Для текущих событий используй research_agent."
      "Для математических задач используйте math_agent."
      "Отвечай всегда по-русски"
    )
)

# ============================================
# Компиляция workflow в исполняемый граф
# ============================================

app = workflow.compile()

# ================================================================
# Визуализация графа агентов — строим PNG с помощью Mermaid
# ================================================================

graph_bytes = app.get_graph().draw_mermaid_png()  # Получаем байтовый PNG графа
image = PILImage.open(BytesIO(graph_bytes))        # Загружаем изображение в PIL
image.show()                                       # Показываем в стандартном просмотрщике

# =====================================================
# Отправляем запрос в многоагентную систему (workflow)
# =====================================================

result = app.invoke({
    "messages": [
        {
            "role": "user",
            "content": "what's the combined headcount of the FAANG companies in 2024?"
        }
    ]
})

# ============================================================
# Выводим весь диалог (включая действия инструментов агентов)
# ============================================================

for m in result['messages']:
    m.pretty_print()  # Удобный формат вывода
