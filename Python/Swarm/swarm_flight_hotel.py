from io import BytesIO              # Для работы с байтовым буфером, нужен чтобы открыть PNG-изображение графа
from PIL import Image as PILImage   # Библиотека Pillow — для загрузки и отображения изображений (PNG графа)
import os                           # Доступ к переменным окружения операционной системы
from dotenv import load_dotenv      # Для подключения переменных окружения из файла .env

# Клиент для локальной модели Ollama (например Qwen3, Llama3)
from langchain_ollama import ChatOllama

# Хранилище состояния (checkpoint) в оперативной памяти
from langgraph.checkpoint.memory import InMemorySaver

# Готовый фабричный метод для создания ReAct-агента
from langgraph.prebuilt import create_react_agent

# Библиотека LangGraph Swarm — инструменты для передачи управления между агентами
from langgraph_swarm import create_handoff_tool, create_swarm


# =====================================================================
# Загружаем переменные окружения (если в проекте нужен LangSmith)
# =====================================================================

load_dotenv()  # Загружает ключи и настройки из .env в окружение (os.environ)

# Считываем значения переменных (если ведём трассировку в LangSmith)
LANGSMITH_API_KEY = os.getenv("LANGSMITH_API_KEY")
LANGCHAIN_TRACING_V2 = os.getenv("LANGCHAIN_TRACING_V2")
LANGCHAIN_PROJECT = os.getenv("LANGCHAIN_PROJECT")


# =====================================================================
# Инициализируем локальную модель через Ollama
# =====================================================================

model = ChatOllama(model="qwen3:latest")  # Используем локальную модель Qwen3 (через Ollama)


# =====================================================================
# Пример простой функции-инструмента, которую сможет вызывать агент
# =====================================================================

def add(a: int, b: int) -> int:
    """Сложить два числа"""
    return a + b


# =====================================================================
# Создаём агента Alice — специалиста по сложению
# =====================================================================

alice = create_react_agent(
    model,                                     # Локальная модель
    [
        add,                                   # Инструмент — сложение
        create_handoff_tool(agent_name="Bob")  # Инструмент передачи управления агенту Bob
    ],
    prompt="Ты Alice, эксперт по сложению..",  # Системное описание агента
    name="Alice",                              # Имя агента внутри Swarm
)


# =====================================================================
# Создаём агента Bob — пират, который умеет передавать запрос обратно Alice
# =====================================================================

bob = create_react_agent(
    model,
    [
        create_handoff_tool(
            agent_name="Alice",
            description="Передай Alice, она может помочь с математикой."
        )   # Инструмент передачи управления Alice
    ],
    prompt="Ты Bob, ты говоришь как пират.You are Bob",  # Bob говорит как пират
    name="Bob",
)


# =====================================================================
# Инициализация хранилища состояния для Swarm
# =====================================================================

checkpointer = InMemorySaver()  # Всё состояние хранится в памяти


# =====================================================================
# Создаём рой агентов (Swarm)
# =====================================================================

workflow = create_swarm(
    [alice, bob],                # Список всех агентов
    default_active_agent="Alice"        # По умолчанию начинает Alice
)

# Компилируем приложение (граф) со встроенным checkpoint
app = workflow.compile(checkpointer=checkpointer)


# =====================================================================
# Визуализация графа агентов (Mermaid → PNG)
# =====================================================================

graph_bytes = app.get_graph().draw_mermaid_png()  # Строим PNG-граф в байтах
image = PILImage.open(BytesIO(graph_bytes))        # Открываем PNG как изображение
image.show()                                       # Показываем в просмотрщике изображений


# =====================================================================
# Тестовые обращения (диалог в одной "сессии" thread_id=1)
# =====================================================================

config = {"configurable": {"thread_id": "1"}}  # Уникальный ID диалога (чтобы сохранялся state)

# Первый запрос — пользователь хочет поговорить с Бобом
turn_1 = app.invoke(
    {"messages": [{"role": "user", "content": "я хотел бы поговорить с Бобом"}]},
    config,
)

# print(turn_1)  # Выводим ответ (возможно, Alice передаст управление Bob)

for m in turn_1['messages']:
    m.pretty_print()  # Удобный формат вывода

# Второй запрос — просим посчитать 5+7
turn_2 = app.invoke(
    {"messages": [{"role": "user", "content": "Сколько будет 5 + 7?"}]},
    config,
)

# print(turn_2)  # Bob может передать управление Alice, и произойдёт вызов функции add()

for m in turn_2['messages']:
    m.pretty_print()  # Удобный формат вывода